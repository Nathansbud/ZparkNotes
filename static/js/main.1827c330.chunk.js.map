{"version":3,"sources":["hooks/useKeyPress.tsx","App.tsx","index.tsx"],"names":["useKeyPress","targetKey","useState","keyPressed","setKeyPressed","downHandler","key","upHandler","useEffect","window","addEventListener","removeEventListener","NoteCard","note","text","book","author","page","date","className","toUpperCase","slice","isNaN","LogoText","App","sheetUrl","process","zparkNotes","setZparkNotes","currentIdx","setCurrentIdx","seenIdxs","setSeenIdxs","failed","zparkView","spacePressed","length","validKeys","Array","keys","filter","idx","includes","console","log","concat","Math","floor","random","Papa","parse","download","complete","parseResult","rows","data","map","row","Date","parseInt","zn","i","ReactDOM","render","document","getElementById"],"mappings":"oMAmCeA,MAhCf,SAAqBC,GAAmB,MAEFC,oBAAS,GAFP,mBAE/BC,EAF+B,KAEnBC,EAFmB,KAKtC,SAASC,EAAT,GAA6C,EAAtBC,MACTL,GACVG,GAAc,GAKlB,IAAMG,EAAY,SAAC,GAA2B,EAAzBD,MACPL,GACVG,GAAc,IAelB,OAVAI,qBAAU,WAIR,OAHAC,OAAOC,iBAAiB,UAAWL,GACnCI,OAAOC,iBAAiB,QAASH,GAE1B,WACLE,OAAOE,oBAAoB,UAAWN,GACtCI,OAAOE,oBAAoB,QAASJ,MAErC,CAACN,IAEGE,GChBHS,G,MAAW,SAAC,GAAmE,IAAD,IAAjEC,KAAOC,EAA0D,EAA1DA,KAAMC,EAAoD,EAApDA,KAAMC,EAA8C,EAA9CA,OAAcC,GAAgC,EAAtCC,KAAsC,EAAhCD,MAAgC,sDAChF,OAAQ,sBAAKE,UAAU,OAAf,UACJ,6BAAKL,EAAK,GAAGM,cAAgBN,EAAKO,MAAM,KACxC,yCAAY,4BAAIN,IAAhB,KAA4BC,EAA5B,KAAsCM,MAAML,IAAP,YAAqBA,WAI5DM,EAAW,WACb,OACI,qBAAIJ,UAAU,eAAd,UACI,8BACI,qBAAKA,UAAU,WAAf,eADJ,WAGA,6CA2FGK,MAtFf,WACI,IAAMC,EAAWC,mKADN,EAGyBxB,mBAAsB,IAH/C,mBAGJyB,EAHI,KAGQC,EAHR,OAKyB1B,mBAAS,GALlC,mBAKJ2B,EALI,KAKQC,EALR,OAMqB5B,mBAAmB,IANxC,mBAMJ6B,EANI,KAMMC,EANN,OAQiB9B,oBAAS,GAR1B,mBAQJ+B,EARI,aASS/B,mBAAoB,SAAjCgC,EATI,oBAWLC,EAAenC,EAAY,KA2CjC,GAzCAQ,qBAAU,WACN,GAAI2B,GAAgBR,EAAWS,OAAS,EACpC,GAAIL,EAASK,OAAS,IAAMT,EAAWS,OACnCJ,EAAY,QACT,CACH,IAAMK,EAAY,YAAIC,MAAMX,EAAWS,QAAQG,QAAQC,QACnD,SAACC,GAAD,QAAWA,IAAQZ,KAAgBE,EAASW,SAASD,MAEzDE,QAAQC,IAAIP,GACZL,EAAYD,EAASc,OAAOhB,IAC5BC,EAAcO,EAAUS,KAAKC,MAAMD,KAAKE,SAAWX,EAAUD,UAIhC,IAAtBT,EAAWS,QACtBa,IAAKC,MAAMzB,EAAU,CACjB0B,UAAU,EACVC,SAAU,SAACC,GACP,IAAMC,EAAOD,EAAYE,KAAKC,KAC1B,SAACC,GAAS,IAAD,EACoCA,EADpC,mBACEvC,EADF,KACQJ,EADR,KACcC,EADd,KACoBC,EADpB,KAC4BC,EAD5B,KAEL,MAAO,CACHH,KAAMA,EACNI,KAAM,IAAIwC,KAAKxC,GACfH,KAAMA,EACNC,OAAQA,EACRC,KAAM0C,SAAS1C,OAI3B0B,QAAQC,IAAIS,GACZvB,EAAcgB,KAAKC,MAAMD,KAAKE,SAAWrB,EAAWS,SACpDR,EAAc0B,QAO3B,CAAC7B,EAAUE,EAAYQ,EAAcN,EAAYE,IAE3B,IAAtBJ,EAAWS,OACV,OAAQ,mCACJ,cAAC,EAAD,MAED,GAAIH,EAqBP,OAAQ,qCACJ,cAAC,EAAD,IACA,0DAtBJ,OAAOC,GACH,IAAK,OACD,OAAGP,EACS,qCACJ,cAAC,EAAD,IACA,cAAC,EAAD,CAAUd,KAAMc,EAAWE,QAG5B,mDACX,IAAK,OACD,OAAQ,qCACJ,cAAC,EAAD,IACA,6BACKF,EAAW6B,KAAI,SAACI,EAAIC,GAAL,OAAY,6BAAaD,EAAG9C,MAAP+C,WAGjD,QACI,OAAQ,cAAC,EAAD,MC1GxBC,IAASC,OACL,cAAC,EAAD,IACAC,SAASC,eAAe,W","file":"static/js/main.1827c330.chunk.js","sourcesContent":["import { useState, useEffect } from 'react';\n\n// Hook\nfunction useKeyPress(targetKey: string) {\n  // State for keeping track of whether key is pressed\n  const [keyPressed, setKeyPressed] = useState(false);\n\n  // If pressed key is our target key then set to true\n  function downHandler({ key }: KeyboardEvent) {\n    if (key === targetKey) {\n      setKeyPressed(true);\n    }\n  }\n\n    // If released key is our target key then set to false\n  const upHandler = ({ key }: KeyboardEvent) => {\n    if (key === targetKey) {\n      setKeyPressed(false);\n    }\n  };\n\n  // Add event listeners\n  useEffect(() => {\n    window.addEventListener('keydown', downHandler);\n    window.addEventListener('keyup', upHandler);\n    // Remove event listeners on cleanup\n    return () => {\n      window.removeEventListener('keydown', downHandler);\n      window.removeEventListener('keyup', upHandler);\n    };\n  }, [targetKey]); // rerun the effect if the targetKey changes\n\n  return keyPressed;\n}\n\nexport default useKeyPress;","import {useState, useEffect} from 'react'\nimport Papa from 'papaparse'\n\nimport useKeyPress from './hooks/useKeyPress'\nimport './App.css'\n\ntype ZparkNote = {\n    text: string,\n    book: string,\n    author: string,\n    date: Date,\n    page: number\n}\ntype ZparkView = 'card' | 'list' | 'log'\n\ntype NoteProps = {note: ZparkNote}\nconst NoteCard = ({note: {text, book, author, date, page, ...props}}: NoteProps) => {    \n    return (<div className='card'>\n        <h2>{text[0].toUpperCase() + text.slice(1)}</h2>\n        <h3>&mdash; <b>{book}</b> ({author}){!isNaN(page) && `, ${page}`}</h3>\n    </div>)    \n}\n\nconst LogoText = () => {\n    return (\n        <h1 className='title center'>\n            <b>\n                <sup className='asterisk'>*</sup>zpark\n            </b>\n            <span>notes</span>\n        </h1>\n    )\n}\n\nfunction App() {\n    const sheetUrl = process.env.REACT_APP_ZPARKNOTES_SHEET_URL\n    \n    const [zparkNotes, setZparkNotes] = useState<ZparkNote[]>([])\n    \n    const [currentIdx, setCurrentIdx] = useState(0)\n    const [seenIdxs, setSeenIdxs] = useState<number[]>([])\n\n    const [failed, setFailed] = useState(false)\n    const [zparkView] = useState<ZparkView>('card')\n    \n    const spacePressed = useKeyPress(' ')\n    \n    useEffect(() => { \n        if (spacePressed && zparkNotes.length > 0) {\n            if (seenIdxs.length + 1 === zparkNotes.length) {\n                setSeenIdxs([])\n            } else {\n                const validKeys = [...Array(zparkNotes.length).keys()].filter(\n                    (idx) => !(idx === currentIdx) && !seenIdxs.includes(idx) \n                )\n                console.log(validKeys)\n                setSeenIdxs(seenIdxs.concat(currentIdx))\n                setCurrentIdx(validKeys[Math.floor(Math.random() * validKeys.length)])\n            }\n        }\n\n        if(sheetUrl && zparkNotes.length === 0) {\n            Papa.parse(sheetUrl, {\n                download: true,\n                complete: (parseResult) => {\n                    const rows = parseResult.data.map(\n                        (row) => {\n                            const [date, text, book, author, page] = row as string[]\n                            return {\n                                text: text,\n                                date: new Date(date),\n                                book: book,\n                                author: author,\n                                page: parseInt(page)\n                            }\n                        }\n                    )\n                    console.log(parseResult)\n                    setCurrentIdx(Math.floor(Math.random() * zparkNotes.length))\n                    setZparkNotes(rows)\n                }            \n            })\n        } else if(!sheetUrl) {\n            console.error(\"No sheet URL specified as an environment variable!\")\n            setFailed(true)\n        }\n    }, [sheetUrl, zparkNotes, spacePressed, currentIdx, seenIdxs])\n    \n    if(zparkNotes.length === 0) {\n        return (<>\n            <LogoText/>\n        </>)\n    } else if(!failed) {\n        switch(zparkView) {\n            case 'card':\n                if(zparkNotes) {\n                    return (<>\n                        <LogoText/>\n                        <NoteCard note={zparkNotes[currentIdx]} />\n                    </>)\n                }\n                return <h1>Loading quotes...</h1>\n            case 'list':\n                return (<>\n                    <LogoText/>\n                    <ul>\n                        {zparkNotes.map((zn, i) => (<li key={i}>{zn.text}</li>))}\n                    </ul>            \n                </>)\n            default:\n                return (<LogoText/>)\n        }\n    } else {\n        return (<>\n            <LogoText/>\n            <p>Failed to load quotes!</p>\n        </>)\n    }\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n    <App/>,\n    document.getElementById('root')\n)\n\n"],"sourceRoot":""}